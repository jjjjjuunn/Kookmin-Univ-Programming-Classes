# 📚 자료구조 및 알고리즘 학습 정리

## 🎯 오늘의 학습 목표
- 피보나치 수열 성능 비교 (재귀 vs 비재귀)
- 정렬 알고리즘 구현 및 최적화
- 백준 문제 해결 과정 분석

---

## 📝 1. 피보나치 수열 최적화

### 1.1 재귀적 구현의 문제점
```python
def Fibo(num):
    if num == 1 or num == 2:
        return 1
    return Fibo(num-1) + Fibo(num-2)
```
- **시간복잡도**: O(2^n) - 기하급수적 증가
- **문제**: 중복 계산으로 인한 비효율성

### 1.2 비재귀적 구현 (최적화)
```python
def Fibo(num):
    if num == 1 or num == 2:
        return 1
    else:
        first = 1
        second = 1
        for i in range(0, num-2):
            result = first + second
            first, second = second, result  # 튜플 언패킹 사용
        return result
```
- **시간복잡도**: O(n) - 선형 시간
- **공간복잡도**: O(1) - 상수 공간
- **핵심**: 튜플 언패킹으로 변수 교환 간소화

### 1.3 성능 측정
```python
import time

start_time = time.time()  # 또는 time.perf_counter()
result = Fibo(30)
end_time = time.time()
print(f"실행 시간: {end_time - start_time:.6f}초")
```

---

## 🔧 2. 정렬 알고리즘 구현

### 2.1 퀵 정렬 (Quick Sort)
```python
def Quick_Sort(A, first, last):
    if first < last:
        pivot_index = Partition(A, first, last)
        Quick_Sort(A, first, pivot_index - 1)
        Quick_Sort(A, pivot_index + 1, last)

def Partition(A, first, last):
    pivot = A[last]
    i = first - 1
    for j in range(first, last):
        if A[j] <= pivot:
            i += 1
            A[i], A[j] = A[j], A[i]  # 핵심: i 증가 후 A[i] 사용
    A[i+1], A[last] = A[last], A[i+1]
    return i+1
```

**Partition 함수 작동 원리:**
- `i`: "pivot보다 작거나 같은 원소들의 마지막 인덱스"
- 작은 값 발견 시 → i 증가 → 해당 위치에 배치
- 최종적으로 pivot을 가운데 위치에 배치

### 2.2 병합 정렬 (Merge Sort)
```python
def mergeSort(A, first, last):
    if first < last:
        mid = (first + last) // 2  # 정수 나눗셈 필수!
        mergeSort(A, first, mid)
        mergeSort(A, mid + 1, last)
        merge(A, first, mid, last)

def merge(A, first, mid, last):
    temp = [0] * (last - first + 1)
    i, j, k = first, mid + 1, 0
    
    # 두 부분 배열 병합
    while i <= mid and j <= last:
        if A[i] <= A[j]:
            temp[k] = A[i]
            i += 1
        else:
            temp[k] = A[j]
            j += 1
        k += 1
    
    # 남은 원소들 복사
    while i <= mid:
        temp[k] = A[i]
        i += 1
        k += 1
    
    while j <= last:
        temp[k] = A[j]
        j += 1
        k += 1
    
    # 원본 배열에 복사
    for i in range(len(temp)):
        A[first + i] = temp[i]
```

---

## 🔍 3. 백준 문제 해결 과정

### 3.1 문제 27434번 (팩토리얼)
**문제**: Python3로 제출 불가, PyPy3는 가능
**원인**: 깊은 재귀 호출로 인한 시간 초과
- 입력: N ≤ 100,000
- Python3: 재귀 호출 오버헤드가 커서 시간 초과
- PyPy3: JIT 컴파일러로 5-10배 빠른 실행

### 3.2 문제 2751번 (수 정렬하기 2)
```python
import sys
N = int(sys.stdin.readline())
nList = [int(sys.stdin.readline()) for _ in range(N)]
nList.sort()
for num in nList:
    print(num)
```
**핵심**: `sys.stdin.readline()` 사용으로 대량 입력 처리

### 3.3 문제 10989번 (수 정렬하기 3)
**조건**: N ≤ 10,000,000, 메모리 제한 8MB
**해결**: 계수 정렬 (Counting Sort)
```python
import sys
N = int(sys.stdin.readline())
count = [0] * 10001  # 1~10000 범위

for _ in range(N):
    num = int(sys.stdin.readline())
    count[num] += 1

for i in range(1, 10001):
    if count[i] > 0:
        for _ in range(count[i]):
            print(i)
```

**사고 과정**:
1. 메모리 계산: 천만 개 × 4바이트 = 40MB > 8MB ❌
2. 수의 범위 주목: 1~10,000 (작은 범위)
3. 아이디어: 각 수의 개수만 세기
4. 구현: 계수 배열 사용

---

## 🚀 4. 최적화 및 성능 분석

### 4.1 연습문제 5: 두 배열의 원소 교체
```python
while change_num < K:
    minimum_num_A_index = A.index(min(A))
    maximum_num_B_index = B.index(max(B))
    if A[minimum_num_A_index] < B[maximum_num_B_index]:
        A[minimum_num_A_index], B[maximum_num_B_index] = B[maximum_num_B_index], A[minimum_num_A_index]
        change_num += 1
    else:
        break  # 더 이상 교환 불필요
```

**성능 분석**:
- 현재 방법: O(K × N) - N=100,000일 때 위험
- 최적화 방법: 정렬 활용 O(N log N)

### 4.2 연습문제 6: 수 찾기 (1920번)
**핵심 최적화**: `list` → `set` 변환
```python
# Before: O(M × N) = 100억 번
for num in B:
    if num in A:  # list 선형 탐색 O(N)

# After: O(M) = 10만 번  
A = set(map(int, sys.stdin.readline().split()))
for x in B:
    if x in A:    # set 해시 탐색 O(1)
```

**성능 차이**: 1000배 향상!

---

## 📊 5. Python 변수 스코프 및 문법

### 5.1 변수 스코프
```python
def example():
    for i in range(3):  # i = 0, 1, 2
        x = i * 2       # x = 0, 2, 4
    print(x)  # 4 출력 (마지막 값 유지)
    return x  # 4 반환
```
- Python은 **함수 레벨 스코프** (블록 스코프 없음)
- for문 내 변수도 함수가 끝날 때까지 유지

### 5.2 튜플 언패킹
```python
first, second = second, result
# 내부 과정: (second, result) 튜플 생성 → 언패킹하여 할당
```

### 5.3 입출력 최적화
```python
# 성능 비교
import sys
input = sys.stdin.readline  # 편의성을 위한 재정의

# 판단 기준
# N ≤ 10,000: input() 사용해도 됨
# N > 10,000: sys.stdin.readline() 권장
# 백준/코테: 무조건 readline() 사용
```

---

## 🎯 6. 핵심 학습 포인트

### 6.1 알고리즘 분석 능력
- **시간복잡도 계산**: 실제 연산 수로 성능 예측
- **병목 지점 식별**: 가장 느린 부분 찾아 최적화
- **자료구조 선택**: 문제 특성에 맞는 구조 활용

### 6.2 문제 해결 패턴
1. **조건 분석** → 시간/메모리 제약 파악
2. **복잡도 계산** → 현실적 실행 가능성 판단  
3. **병목 식별** → 성능 저해 요소 찾기
4. **최적화** → 적절한 알고리즘/자료구조 선택

### 6.3 실무 적용 가능한 최적화 기법
- **존재 여부 확인**: `list` → `set` 활용
- **대량 입출력**: `sys.stdin.readline()` 사용
- **메모리 제약**: 계수 정렬 등 특수 알고리즘
- **재귀 최적화**: 반복문으로 변환

---

## 📈 7. 다음 학습 방향

### 7.1 추천 학습 주제
- **그래프 알고리즘**: DFS, BFS, 다익스트라
- **동적 프로그래밍**: 메모이제이션, 최적 부분구조
- **고급 자료구조**: 힙, 트리, 세그먼트 트리
- **문자열 알고리즘**: KMP, 라빈-카프

### 7.2 실력 향상 방법
- **백준 단계별 문제**: 체계적 학습
- **시간복잡도 분석 습관화**: 코드 작성 전 예측
- **다양한 최적화 기법**: 상황별 적절한 방법 선택
- **코드 리뷰**: 더 효율적인 방법 탐색

---

*"알고리즘 최적화는 단순히 빠른 코드를 만드는 것이 아니라, 문제의 본질을 파악하고 가장 적합한 해결 방법을 찾는 과정이다."* 🚀